#pragma once
namespace csgo::hacks {

	class c_exploits {
	private:
		int get_type( );

		struct cfg_t {
			s_keybind m_dt_key { };
			int m_cur_shift_amount{ };
		};

		sdk::cfg_var_t< cfg_t > m_cfg { 0x05562b95u, { } };
	public:
		void handle_context( valve::user_cmd_t& user_cmd );

		bool try_to_recharge( bool& send_packet, valve::user_cmd_t& user_cmd );

		bool is_peeking( sdk::qang_t& angle, float ticks );

		int clock_correction( ) const;

		int adjust_tick_base( 
			const int old_new_cmds,
			const int total_new_cmds, const int delta
		 ) const;

		void handle_break_lc( const std::uintptr_t ecx, const std::uintptr_t edx, const int slot, cc_def( valve::bf_write_t* ) buffer, int& from, int& to, cc_def( valve::move_msg_t* ) move_msg );

		void process_real_cmds( const std::uintptr_t ecx, const std::uintptr_t edx, const int slot, cc_def( valve::bf_write_t* ) buffer, int& from, int& to, cc_def( valve::move_msg_t* ) move_msg );

		void skip_lag_interpolation( bool status );

		bool m_allow_choke{ };

		__forceinline cfg_t& cfg( ) { return m_cfg.value( ); };

		bool m_charged{ }, m_shift_cycle{ }, m_force_fake_shift{ };
		int	 m_ticks_allowed{ },
			m_next_shift_amount{ }, m_recharge_cmd{ }, m_type{ }, m_wtf{ }, m_prediction_tick{ };

		int m_last_defensive_tick{ }, m_last_shift_tick{ };

		bool m_magic_bool{ }, m_should_send{ }, m_peeking_someone{ }, m_cl_move_manipulation{ }, m_packet_end_being_called{ };
	};

	inline const auto g_exploits = std::make_unique< c_exploits >( );
}

#include "impl/exploits.inl"
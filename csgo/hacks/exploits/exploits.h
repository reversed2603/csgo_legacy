#pragma once
namespace csgo::hacks { 

	class c_exploits { 
	private:
		int get_type( );

		struct cfg_t { 
			s_keybind m_dt_key { };
		};

		sdk::cfg_var_t< cfg_t > m_cfg { 0x05562b95u, { } };
	public:
		
		enum exploits_type_t : int { 
			type_none = 0,
			type_doubletap = 3,
			type_ready = 4,
			type_defensive = 5
		};

		void handle_context( game::user_cmd_t& user_cmd );

		bool try_to_recharge( bool& send_packet, game::user_cmd_t& user_cmd );

		bool is_peeking( sdk::qang_t& angle, float ticks, bool auto_stop );

		int clock_correction( ) const;

		int adjust_tick_base( 
			const int old_new_cmds,
			const int total_new_cmds, const int delta
		 ) const;

		void handle_break_lc( const std::uintptr_t ecx, const std::uintptr_t edx, const int slot, cc_def( game::bf_write_t* ) buffer, int& from, int& to, cc_def( game::move_msg_t* ) move_msg );

		void process_real_cmds( const std::uintptr_t ecx, const std::uintptr_t edx, const int slot, cc_def( game::bf_write_t* ) buffer, int& from, int& to, cc_def( game::move_msg_t* ) move_msg );

		void skip_lag_interpolation( bool status );

		bool m_allow_choke{ };

		__forceinline cfg_t& cfg( ) { return m_cfg.value( ); };

		bool m_charged{ }, m_shift_cycle{ }, m_had_target{ };
		int	 m_ticks_allowed{ },
			m_next_shift_amount{ }, m_recharge_cmd{ }, m_type{ }, m_simulation_diff{ }, m_prediction_tick{ };

		int m_process_ticks{ 0 };
		int m_cur_shift_amount{ 0 };
		int m_max_process_ticks;
		int m_last_processed{ };
		int m_last_defensive_tick{ }, m_last_shift_tick{ };

		bool is_in_defensive{ false };
		bool m_peeking_someone{ };
		bool m_in_charge{ };


		const int m_max_charge{ 15 };
	};

	inline const auto g_exploits = std::make_unique< c_exploits > ( );
}

#include "impl/exploits.inl"
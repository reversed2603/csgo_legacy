#pragma once
namespace csgo::hacks { 

	class c_exploits { 
	private:
		struct tickbase_data_t {
			int tickbase{ };
			int command_number{ };
			int shift_amount{ };
			int cmd_diff{ };
			bool restore_tickbase{ };
		} data;
		void start_shift( game::user_cmd_t* cmd, int amount );

		bool m_is_dt_toggled{ };
		bool m_is_dt_active{ };
		bool m_is_dt_disabled{ };
		bool m_teleport{ };

		struct cfg_t { 
			s_keybind m_dt_key { };
		};

		sdk::cfg_var_t< cfg_t > m_cfg { 0x05562b95u, { } };
	public:
		bool m_charge{ },
			m_recharge{ },
			m_charged{ },
			m_stop_movement{ },
			m_lag_during_shift{ },
			m_can_lag{ },
			m_break_lc{ },
			m_skip_interp{ },
			m_charge_dt{ };

		int  m_interp_tick{ };
		int  m_interp_amt{ };
		int m_ticks_to_charge{ },
			m_max_process_ticks{ },
			m_ticks_to_shift{ };

		void limit_ticks( );

		struct cl_move_t {
			bool m_can_shift = false;
			bool m_shifting = false;
			int m_ticks_to_shift = 0;
		} cl_move_data;

		int m_shift_amount{ };
		int m_shift_timer{ };
		int m_allowed_ticks{ };
		int m_dt_bullets{ };

		__forceinline void reset_shift( );

		__forceinline bool recharged( );

		__forceinline bool dt_enabled( );

		bool is_recharging( );

		void double_tap( game::user_cmd_t* cmd );

		void handle_break_lc (
			const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
			cc_def( game::bf_write_t* ) buffer, int& from, int& to, cc_def( game::move_msg_t* ) move_msg
		 );

		void on_pre_predict( );
		void on_predict_start( game::user_cmd_t* cmd );

		bool is_peeking( sdk::qang_t& angle, float ticks, bool auto_stop );

		void store( int tickbase, int cmd, int shift, bool restore, int cmd_diff = 1 );
		void fix( int new_command_number, int& tickbase );

		void on_cl_move( );
		void setup_interp( bool post_frame );

		__forceinline cfg_t& cfg( ) { return m_cfg.value( ); };
	};

	inline const auto g_exploits = std::make_unique< c_exploits > ( );
}

#include "impl/exploits.inl"
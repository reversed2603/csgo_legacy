#include "../../../csgo.hpp"

namespace csgo::hacks {
	bool c_exploits::is_peeking( sdk::qang_t& angle, float ticks, bool auto_stop ) {
        if( !g_local_player->self( ) ||
            !g_local_player->self( )->weapon( ) 
            || !g_local_player->self( )->weapon( )->info( )
            || g_local_player->self( )->weapon( )->info( )->m_type == game::e_weapon_type::knife
            || g_local_player->self( )->weapon( )->item_index( ) == game::e_item_index::taser )
            return false;
            
        if( g_local_player->self( )->velocity( ).length( 2u ) < ( auto_stop ? 8.5f : 2.5f ) )
            return false;

        for( int i = 1; i <= game::g_global_vars.get( )->m_max_clients; ++i ) {
            auto& entry = hacks::g_lag_comp->entry( i - 1 );

            if( !g_local_player->self( )
                || !g_local_player->self( )->alive( ) )
                continue;

            if( !entry.m_player 
				|| !entry.m_player->alive( )
                || entry.m_player == g_local_player->self( )
                || entry.m_player->networkable( )->dormant( )
                || entry.m_player->friendly( g_local_player->self( ) )
				|| entry.m_lag_records.empty( ) )
                continue;

            aim_target_t target{ &entry, entry.m_lag_records.front( ) };
            target.m_points.clear( );

            sdk::vec3_t next_shot_pos = g_ctx->shoot_pos( ) + ( g_local_player->self( )->velocity( ) * game::g_global_vars.get( )->m_interval_per_tick ) * ticks;
            std::vector< point_t > points{ };

            lag_backup_t lag_backup{ };
            lag_backup.setup( target.m_entry->m_player );

            g_aim_bot->scan_center_points( target, target.m_lag_record.value( ), next_shot_pos, points );

            lag_backup.restore( target.m_entry->m_player );

            if( g_aim_bot->scan_points( &target, points ) ) {
                return true;
                break;
            }
        }

		return false;
    }

	void c_exploits::store( int tickbase, int cmd, int shift, bool restore, int cmd_diff ) {
		data.tickbase = tickbase;
		data.command_number = cmd;
		data.shift_amount = shift;
		data.restore_tickbase = restore;
		data.cmd_diff = cmd_diff;
	}

	void c_exploits::fix( int new_command_number, int& tickbase ) {
		if( data.command_number <= 0 )
			return;

		if( data.command_number == new_command_number )
			tickbase = data.tickbase - data.shift_amount + game::g_global_vars.get( )->m_sim_ticks_this_frame;

		if( data.restore_tickbase && data.command_number + data.cmd_diff == new_command_number )
			tickbase += data.shift_amount - game::g_global_vars.get( )->m_sim_ticks_this_frame;
	}

	void c_exploits::handle_break_lc(
        const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
        cc_def( game::bf_write_t* ) buffer, int& from, int& to, cc_def( game::move_msg_t* ) move_msg
	 ) {
        auto shift_amount = m_shift_amount;

        m_shift_amount = 0;

        const auto old_new_cmds = move_msg.get( )->m_new_cmds;

        move_msg.get( )->m_new_cmds = std::clamp( move_msg.get( )->m_new_cmds + shift_amount, 1, crypt_int( 62 ) );
        move_msg.get( )->m_backup_cmds = 0;

        const auto next_cmd_number = game::g_client_state.get( )->m_last_cmd_out + game::g_client_state.get( )->m_choked_cmds + crypt_int( 1 );

        for( to = next_cmd_number - old_new_cmds + 1; to <= next_cmd_number; ++to ) {
            if( !hooks::orig_write_user_cmd_delta_to_buffer( ecx, edx, slot, buffer.get( ), from, to, true ) )
                return;

            from = to;
        }

        const auto user_cmd = game::g_input->user_cmd( slot, from );
        if( !user_cmd )
            return;

        auto from_user_cmd = *user_cmd, to_user_cmd = *user_cmd;

        if( shift_amount ) {
            ++to_user_cmd.m_number;

            to_user_cmd.m_tick += 200;

			while( --shift_amount > 0 ) {
                buffer.get( )->write_user_cmd( &to_user_cmd, &from_user_cmd );

                from_user_cmd = to_user_cmd;

                ++to_user_cmd.m_number;
				++to_user_cmd.m_tick;
            };
        }
    }

	void c_exploits::start_shift( game::user_cmd_t* cmd, int amount ) {
		if( m_allowed_ticks < amount )
			return;

		if( !m_stop_movement )
			m_stop_movement = true;

		cl_move_data.m_can_shift = true;
		cl_move_data.m_ticks_to_shift = amount;
	}

	void c_exploits::setup_interp( bool post_frame )
	{
		if( !g_local_player->self( ) 
			|| !g_local_player->self( )->alive( ) )
			return;

		/* if its post frame, restore interpolation amount */
		if( post_frame )
		{
			game::g_global_vars.get( )->m_interp_amt = m_interp_amt;
			return;
		}

		m_interp_amt = game::g_global_vars.get( )->m_interp_amt;

		if( m_skip_interp ) // should we skip interpolation?
			game::g_global_vars.get( )->m_interp_amt = 0.0f;

		// start fixing final prediction tick.
		g_local_player->self( )->final_pred_tick( ) = g_local_player->self( )->tick_base( ) + static_cast < int > ( m_skip_interp );
	}

	bool c_exploits::is_recharging( ) {
		static int last_choke{ 0 };
		if( m_recharge && !last_choke ) {
			if( ++m_allowed_ticks >= m_ticks_to_charge ) {
				m_recharge = false;
				m_charged = true;
				m_stop_movement = true;

				m_skip_interp = false;
			}

			m_shift_amount = 0;

			m_skip_interp = true;

			m_lag_during_shift = false;
			m_can_lag = false;
			return true;
		}
		else
			last_choke = game::g_client_state.get( )->m_choked_cmds;	

		return false;
	}

	void c_exploits::on_pre_predict( ) {
		/* limit recharge/shift ticks. */
		limit_ticks( );

		static bool has_dt = false;

		if( g_key_binds->get_keybind_state( &m_cfg->m_dt_key ) ) {
			if( !has_dt ) {
				m_is_dt_active = true;
				has_dt = true;
			}
		}
		else
			has_dt = false;

		bool active = m_is_dt_toggled && m_is_dt_active;

		if( m_allowed_ticks < m_ticks_to_charge 
			&& active ) {
			m_recharge = true;
			m_charged = false;
		}
	}

	void c_exploits::on_predict_start( game::user_cmd_t* cmd ) {
		if( cl_move_data.m_can_shift )
			return;

		double_tap( cmd );
	}

	void c_exploits::double_tap( game::user_cmd_t* cmd ) {
		if( !g_local_player->self( ) 
			|| !g_local_player->self( )->alive( ) )
			return;

		auto weapon = g_local_player->self( )->weapon( );
		if( !weapon )
			return;
            
		static bool m_start_recharge = false;

		if( m_start_recharge )
		{
			m_charge_dt = true;
			m_start_recharge = false;
			reset_shift( );
			return;
		}

		if( m_charge_dt )
		{
			float shot_diff = std::abs( weapon->last_shot_time( ) - game::g_global_vars.get( )->m_cur_time );
			if( ( shot_diff >= 0.3f && !cl_move_data.m_can_shift ) ) // check if last shot time was more than 500ms, make sure we can't shift
			{
				m_teleport = g_key_binds->get_keybind_state( &m_cfg->m_dt_key );

				m_dt_bullets = 0;
				m_charge_dt = false;
				m_is_dt_active = true;
			}

			return;
		}

		if( !g_key_binds->get_keybind_state( &m_cfg->m_dt_key ) ) {
			m_is_dt_toggled = false;

			if( !m_is_dt_disabled ) {
				m_stop_movement = true;

				if( m_teleport ) {
					start_shift( cmd, m_ticks_to_shift );
					m_teleport = false;
				}

				reset_shift( );

				m_is_dt_disabled = true;
			}
			return;
		}

		m_is_dt_toggled = true;
		m_is_dt_disabled = false;

		if( !m_charged )
			return;

		if( !m_teleport )
			m_teleport = true;

		bool can_dt = weapon->item_index( ) != game::e_item_index::taser
			&& weapon->item_index( ) != game::e_item_index::revolver;

		if( can_dt 
			&& ( cmd->m_buttons & game::e_buttons::in_attack 
				&& !cmd->m_weapon_select ) ){

			/* collect pre-shift tickbase */
			store( g_local_player->self( )->tick_base( ), cmd->m_number, m_ticks_to_shift + 1, true ); // later find a better way

			/* start shifting */
			start_shift( cmd, m_ticks_to_shift );

			m_dt_bullets++;
			m_is_dt_toggled = false;
			m_is_dt_active = false;
			m_lag_during_shift = false;
			m_can_lag = false;
			m_start_recharge = true;
			return; // don't call defensive double-tap
		}

		/* do our defensive below */

		if( is_peeking( cmd->m_view_angles, 6.f, false )
			&& weapon->item_index( ) != game::e_item_index::revolver ) {
			if( !m_can_lag ) {
				if( !m_lag_during_shift ) {
					m_shift_timer = 0;
					m_lag_during_shift = true;
				}

				m_can_lag = true;
			}
		}
		else {
			m_lag_during_shift = false;
			m_can_lag = false;
		}

		if( m_lag_during_shift ) {
			m_shift_amount = m_shift_timer > 0 ? m_ticks_to_shift : 0;

			if( ++m_shift_timer >= m_ticks_to_shift ) {
				m_shift_timer = 0;
				m_lag_during_shift = false;
			}
		}
		else {
			m_shift_amount = m_ticks_to_shift;
			m_shift_timer = 0;
			m_can_lag = false;
		}
	}

	void c_exploits::on_cl_move( ) {
		if( !g_local_player->self( ) 
			|| !g_local_player->self( )->alive( )
			|| !cl_move_data.m_can_shift )
			return;

		while( --cl_move_data.m_ticks_to_shift >= 0 ) {
			if( cl_move_data.m_ticks_to_shift >= m_ticks_to_shift )
				g_ctx->send_packet( ) = false;

			cl_move_data.m_shifting = true;
			hooks::orig_cl_move( 0.f, cl_move_data.m_ticks_to_shift <= 0 );
		}

		cl_move_data.m_can_shift = false;
		cl_move_data.m_shifting = false;
	}
}
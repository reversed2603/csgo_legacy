#include "../../../csgo.hpp"

namespace csgo::hacks {
    int c_exploits::get_type ( ) {
        if ( !g_local_player->self ( ) )
            return 0;

        if ( g_key_binds->get_keybind_state ( &m_cfg->m_dt_key ) )
            return 3;

        return 0;
    }

    bool c_exploits::is_peeking ( sdk::qang_t& angle, float ticks ) {
        m_peeking_someone = false;

        if ( !g_local_player->self ( ) ||
            !g_local_player->self ( )->weapon ( ) 
            || !g_local_player->self ( )->weapon( )->info ( )
            || g_local_player->self ( )->weapon( )->info ( )->m_type == valve::e_weapon_type::knife
            || g_local_player->self( )->weapon( )->item_index ( ) == valve::e_item_index::taser )
            return false;
            
        if ( g_local_player->self ( )->velocity ( ).length ( 2u ) < 16.f )
            return false;

        for ( int i = 1; i <= valve::g_global_vars.get ( )->m_max_clients; ++i ) {
            auto& entry = hacks::g_lag_comp->entry ( i - 1 );

            if ( !g_local_player->self ( )
                || !g_local_player->self ( )->alive ( ) )
                continue;

            if ( !entry.m_player || !entry.m_player->alive ( )
                || entry.m_player == g_local_player->self ( )
                || entry.m_player->networkable ( )->dormant ( )
                || entry.m_player->friendly ( g_local_player->self ( ) ) )
                continue;

            if ( entry.m_lag_records.empty ( ) )
                continue;

            aim_target_t target{};
            target.m_entry = &entry;
            target.m_lag_record = entry.m_lag_records.front( );

            target.m_points.clear( );

            sdk::vec3_t next_shot_pos = g_ctx->shoot_pos( ) + ( g_local_player->self( )->velocity( ) * valve::g_global_vars.get( )->m_interval_per_tick ) * ticks;
            std::vector < point_t > points{};

            lag_backup_t lag_backup{};
            lag_backup.setup( target.m_entry->m_player );

            g_aim_bot->scan_center_points( target, target.m_lag_record.value( ), next_shot_pos, points );

            lag_backup.restore( target.m_entry->m_player );

            if ( g_aim_bot->scan_points( &target, points ) ) {
                m_peeking_someone = true;
                break;
            }
        }

        return m_peeking_someone;
    }

    void c_exploits::handle_context( valve::user_cmd_t& user_cmd ) {

        const auto weapon = g_local_player->self ( )->weapon ( );
        const auto wpn_data = weapon ? weapon->info ( ) : nullptr;

        int shift_amount {};

        if ( ( m_type = get_type ( ) ) ) {
            if ( weapon ) {
                const auto item_index = weapon->item_index ( );
                if ( item_index != valve::e_item_index::taser
                    && item_index != valve::e_item_index::c4
                    && !( item_index >= valve::e_item_index::flashbang && item_index <= valve::e_item_index::inc_grenade ) ) {
                    if ( m_ticks_allowed ) {
                        if ( m_type == 1 )
                            shift_amount = 8;
                        else if ( m_type == 2 || m_type == 3 ) {
                            if ( hacks::g_aim_bot->can_shoot ( false, 0, false ) )
                                shift_amount = m_ticks_allowed;
                        }

                        if ( valve::g_global_vars.get ( )->m_cur_time >= g_local_player->self ( )->next_attack ( ) ) {
                            m_next_shift_amount = shift_amount;
                        }

                        goto prepare_cheat;
                    }
                }
            }
        };

        shift_amount = m_cur_shift_amount = m_next_shift_amount = 0;
        if ( !m_type
            && m_ticks_allowed > 0 ) {
            m_type = 4;
            m_cur_shift_amount = m_next_shift_amount = m_ticks_allowed;

            m_charged = true;
        }

    prepare_cheat:
        if ( weapon
            && weapon->item_index ( ) == valve::e_item_index::revolver ) {
            g_eng_pred->r8_can_shoot ( ) = true;

            user_cmd.m_buttons &= ~valve::e_buttons::in_attack2;

            if ( hacks::g_aim_bot->can_shoot ( true, 0, true ) ) {
                if ( valve::g_global_vars.get ( )->m_cur_time < g_eng_pred->postpone_fire_ready_time ( ) )
                    user_cmd.m_buttons |= valve::e_buttons::in_attack;
                else if ( valve::g_global_vars.get ( )->m_cur_time < weapon->next_secondary_attack ( ) )
                    user_cmd.m_buttons |= valve::e_buttons::in_attack2;
                else
                    g_eng_pred->postpone_fire_ready_time ( ) = valve::g_global_vars.get ( )->m_cur_time + crypt_float ( 0.234375f );

                g_eng_pred->r8_can_shoot ( ) = valve::g_global_vars.get ( )->m_cur_time > g_eng_pred->postpone_fire_ready_time ( );
            }
            else {
                user_cmd.m_buttons &= ~valve::e_buttons::in_attack;

                g_eng_pred->postpone_fire_ready_time ( ) = valve::g_global_vars.get ( )->m_cur_time + crypt_float ( 0.234375f );

                g_eng_pred->r8_can_shoot ( ) = false;
            }
        }

        if ( ( m_charged )
            && ( user_cmd.m_buttons & valve::e_buttons::in_attack ) 
            && wpn_data->m_type != valve::e_weapon_type::grenade )
            user_cmd.m_buttons &= ~valve::e_buttons::in_attack;

        g_ctx->in_charge( ) = false;

        if ( g_ctx->anim_data( ).m_local_data.m_shot_valid_wpn
            && g_ctx->anim_data( ).m_local_data.m_shot_cmd_number > valve::g_client_state.get ( )->m_last_cmd_out
            && g_ctx->anim_data( ).m_local_data.m_shot_cmd_number < ( valve::g_client_state.get ( )->m_last_cmd_out + crypt_int ( 100 ) ) )
            g_ctx->in_charge( ) = true;

        if ( m_charged )
            m_allow_choke = false;
        else {
            if ( m_type
                && m_ticks_allowed ) {
                if ( valve::g_client_state.get ( )->m_net_chan->m_choked_packets >= crypt_int ( 1 ) )
                    m_allow_choke = false;
                else
                    m_allow_choke = true;
            }
            else {
                if ( valve::g_client_state.get ( )->m_net_chan->m_choked_packets >= crypt_int ( 14 ) )
                    m_allow_choke = false;
                else
                    m_allow_choke = true;
            }
        }

        if ( ( m_charged )
            && ( user_cmd.m_buttons & valve::e_buttons::in_attack )
            && wpn_data->m_type != valve::e_weapon_type::grenade )
            user_cmd.m_buttons &= ~valve::e_buttons::in_attack;

        if (g_aim_bot->can_shoot( false, 0, false ) )
            g_ctx->can_shoot( ) = true;
        else
            g_ctx->can_shoot( ) = false;
    }

    void c_exploits::skip_lag_interpolation ( bool process )
    {
        if ( !g_local_player->self ( ) || !g_local_player->self ( )->alive ( ) )
            return;

        if ( m_recharge_cmd != valve::g_client_state.get ( )->m_last_cmd_out )
            return;

        if ( !process )
        {
            m_prediction_tick = g_local_player->self ( )->final_pred_tick( );

            g_local_player->self ( )->final_pred_tick( ) = valve::g_global_vars.get ( )->m_tick_count + valve::to_ticks( valve::g_engine->net_channel_info( )->latency( 0 ) + valve::g_engine->net_channel_info( )->latency( 1 ) );
            return;
        }

        g_local_player->self ( )->final_pred_tick( ) = m_prediction_tick;
    }

    bool c_exploits::try_to_recharge ( bool& send_packet, valve::user_cmd_t& user_cmd ) {
        if ( ( valve::g_global_vars.get ( )->m_cur_time - g_local_player->self ( )->spawn_time ( ) ) < 1.f )
            return false;

        if ( g_aim_bot->stop_type( )
            || g_ctx->anim_data ( ).m_local_data.m_old_shot )
            return false;

        if ( m_recharge_cmd != valve::g_client_state.get ( )->m_last_cmd_out
            && ( valve::g_client_state.get ( )->m_choked_cmds || m_ticks_allowed >= crypt_int ( 14 ) ) )
            return false;

        if ( !get_type ( )
            || std::abs ( g_ctx->anim_data ( ).m_local_data.m_last_shot_time - valve::g_global_vars.get ( )->m_cur_time ) < crypt_float ( 0.30f ) )
            return false;

        if ( m_ticks_allowed >= crypt_int ( 14 ) ) {
            m_charged = true;

            if ( ( m_ticks_allowed + 1 ) <= crypt_int ( 16 ) ) {
                if ( m_ticks_allowed < 0 )
                    m_ticks_allowed = 0;
            }
            else
                m_ticks_allowed = 15;  

            return false;
        }

        m_recharge_cmd = valve::g_client_state.get ( )->m_last_cmd_out;

        if ( ++m_ticks_allowed > crypt_int ( 16 ) )
            m_ticks_allowed = crypt_int( 16 );

        return true;
    }

    int c_exploits::clock_correction ( ) const {

        static auto sv_clockcorrection_msecs = valve::g_cvar->find_var ( xor_str ( "sv_clockcorrection_msecs" ) );

        return valve::g_global_vars.get ( )->m_max_clients <= 1
            ? -1 : valve::to_ticks ( std::clamp ( sv_clockcorrection_msecs->get_float ( ) / 1000.f, 0.f, 1.f ) );
    }

    int c_exploits::adjust_tick_base (
        const int old_new_cmds,
        const int total_new_cmds, const int delta
    ) const {
        auto final_tick_base = -1;

        const auto correction_ticks = clock_correction( );
        if ( correction_ticks != -1 ) {
            const auto& prev_local_data = g_eng_pred->local_data ( ).at ( valve::g_client_state.get ( )->m_last_cmd_out % 150 );
            if ( prev_local_data.m_spawn_time == g_local_player->self ( )->spawn_time ( ) ) {
                final_tick_base = prev_local_data.m_tick_base + crypt_int ( 1 );

                const auto tick_count = final_tick_base + old_new_cmds - m_wtf;

                const auto ideal_final_tick = tick_count + correction_ticks;

                const auto too_fast_limit = ideal_final_tick + correction_ticks;
                const auto too_slow_limit = ideal_final_tick - correction_ticks;

                const auto estimated_final_tick = final_tick_base + total_new_cmds;

                if ( estimated_final_tick > too_fast_limit
                    || estimated_final_tick < too_slow_limit ) {
                    final_tick_base = ideal_final_tick - total_new_cmds;
                }
            }
        }

        if ( final_tick_base != -1 )
            return final_tick_base;

        const auto& local_data = g_eng_pred->local_data ( ).at ( ( valve::g_client_state.get ( )->m_last_cmd_out + 1 ) % 150 );

        return ( local_data.m_spawn_time == g_local_player->self ( )->spawn_time ( )
            ? local_data.m_tick_base : g_local_player->self ( )->tick_base ( ) ) - delta;
    }

    void c_exploits::handle_break_lc (
        const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
        cc_def( valve::bf_write_t* ) buffer, int& from, int& to, cc_def( valve::move_msg_t* ) move_msg
    ) {
        auto shift_amount = m_cur_shift_amount;

        m_cur_shift_amount = 0;

        const auto actual_cmds = std::min ( move_msg.get ( )->m_new_cmds + m_ticks_allowed, crypt_int ( 16 ) );

        int ticks_allowed {};

        const auto who_tf = actual_cmds - move_msg.get( )->m_new_cmds;
        if ( who_tf >= 0 )
            ticks_allowed = who_tf;

        m_ticks_allowed = ticks_allowed;

        const auto old_new_cmds = move_msg.get( )->m_new_cmds;

        move_msg.get( )->m_new_cmds = std::clamp ( move_msg.get( )->m_new_cmds + shift_amount, 1, crypt_int( 62 ) );
        move_msg.get( )->m_backup_cmds = 0;

        const auto next_cmd_number = valve::g_client_state.get ( )->m_last_cmd_out + valve::g_client_state.get ( )->m_choked_cmds + crypt_int ( 1 );

        for ( to = next_cmd_number - old_new_cmds + 1; to <= next_cmd_number; ++to ) {
            if ( !hooks::orig_write_user_cmd_delta_to_buffer ( ecx, edx, slot, buffer.get ( ), from, to, true ) )
                return;

            from = to;
        }

        for ( auto i = valve::g_client_state.get ( )->m_last_cmd_out + 1; i <= next_cmd_number; ++i )
            hacks::g_eng_pred->local_data ( ).at ( i % 150 ).m_fake_amount = shift_amount;

        const auto user_cmd = valve::g_input->user_cmd ( slot, from );
        if ( !user_cmd )
            return;

        auto from_user_cmd = *user_cmd, to_user_cmd = *user_cmd;

        if ( shift_amount ) {
            ++to_user_cmd.m_number;

            to_user_cmd.m_tick = std::numeric_limits< int >::max ( );

            do {
                buffer.get ( )->write_user_cmd( &to_user_cmd, &from_user_cmd );

                from_user_cmd = to_user_cmd;

                ++to_user_cmd.m_number;

                --shift_amount;
            } while ( shift_amount );
        }
    }
    __forceinline bool is_zero_vec3_t ( sdk::vec3_t vec )
    {
        return ( vec.x ( ) > -0.01f && vec.x ( ) < 0.01f &&
            vec.y ( ) > -0.01f && vec.y ( ) < 0.01f &&
            vec.z ( ) > -0.01f && vec.z ( ) < 0.01f );
    }

    template<typename T>
    void limit_val ( T& value, const T& min, const T& max )
    {
        if ( value > max )
            value = max;
        else if ( value < min )
            value = min;
    }


    void c_exploits::process_real_cmds (
        const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
        cc_def( valve::bf_write_t* ) buffer, int& from, int& to, cc_def( valve::move_msg_t* ) move_msg
    ) {
        auto shift_amount = m_cur_shift_amount;

        m_cur_shift_amount = 0;

        const auto actual_cmds = std::min ( move_msg.get ( )->m_new_cmds + m_ticks_allowed, 16 );

        int new_ticks_allowed {};

        auto wtf = actual_cmds - move_msg.get( )->m_new_cmds;

        wtf -= shift_amount;

        if ( wtf >= 0 )
            new_ticks_allowed = wtf;

        m_ticks_allowed = new_ticks_allowed;

        const auto old_new_cmds = move_msg.get( )->m_new_cmds;

        move_msg.get( )->m_new_cmds = std::clamp ( move_msg.get( )->m_new_cmds + shift_amount, 1, crypt_int ( 62 ) );
        move_msg.get( )->m_backup_cmds = 0;

        auto first_tick_base = adjust_tick_base ( old_new_cmds, move_msg.get( )->m_new_cmds, shift_amount );

        const auto next_cmd_number = valve::g_client_state.get ( )->m_last_cmd_out + valve::g_client_state.get ( )->m_choked_cmds + crypt_int ( 1 );

        for ( to = next_cmd_number - old_new_cmds + 1; to <= next_cmd_number; ++to ) {
            if ( !hooks::orig_write_user_cmd_delta_to_buffer ( ecx, edx, slot, buffer.get ( ), from, to, true ) )
                return;

            from = to;
        }

        for ( auto i = valve::g_client_state.get ( )->m_last_cmd_out + 1; i <= next_cmd_number; ++i ) {
            auto& local_data = hacks::g_eng_pred->local_data ( ).at ( i % 150 );

            local_data.m_fake_amount = 0;
            local_data.m_override_tick_base = true;
            local_data.m_restore_tick_base = local_data.m_restore_tick_base;
            local_data.m_adjusted_tick_base = first_tick_base++;
        }

        const auto user_cmd = valve::g_input->user_cmd ( slot, from );
        if ( !user_cmd )
            return;

        auto from_user_cmd = *user_cmd, to_user_cmd = *user_cmd;

        ++to_user_cmd.m_number;

        valve::g_prediction->m_prev_start_frame = -1;
        valve::g_prediction->m_cmds_predicted = crypt_int ( 0 );

        sdk::vec2_t target_move {};

        m_shift_cycle = true;
        ++valve::g_client_state.get ( )->m_choked_cmds;
        ++valve::g_client_state.get ( )->m_net_chan->m_choked_packets;
        ++valve::g_client_state.get ( )->m_net_chan->m_out_seq;

        const auto& local_data = hacks::g_eng_pred->local_data( ).at( next_cmd_number % crypt_int( 150 ) );
        target_move = { local_data.m_move.x( ), local_data.m_move.y( ) };

        int shifted_cmds {};

        do {
            valve::g_prediction->update(
                valve::g_client_state.get( )->m_delta_tick,
                valve::g_client_state.get( )->m_delta_tick > 0,
                valve::g_client_state.get( )->m_last_cmd_ack,
                valve::g_client_state.get( )->m_last_cmd_out + valve::g_client_state.get( )->m_choked_cmds
            );
            to_user_cmd.m_buttons &= static_cast< valve::e_buttons >( ~4290707449u );
            to_user_cmd.m_move = {};
            if ( g_local_player->self( )->alive( ) ) {
                if ( m_type != 4
                    && !( to_user_cmd.m_buttons & valve::e_buttons::in_jump )
                    && g_local_player->self( )->flags( ) & valve::e_ent_flags::on_ground ) {
                    int v17{};
                    if ( ( shift_amount - crypt_int( 2 ) ) >= 0 )
                        v17 = shift_amount - crypt_int( 1 );

                    static sdk::qang_t wtf{};

                    if ( shifted_cmds >= v17 ) {
                        hacks::g_aim_bot->stop_type( ) = 2;
                        hacks::g_move->auto_stop( to_user_cmd, wtf, 0.f );
                    }
                    else {
                        to_user_cmd.m_move.x( ) = target_move.x( );
                        to_user_cmd.m_move.y( ) = target_move.y( );
                    }
                }

                if ( m_type == 4 ) {
                    to_user_cmd.m_move.x( ) = target_move.x( );
                    to_user_cmd.m_move.y( ) = target_move.y( );
                }

                if ( !is_zero_vec3_t ( g_ctx->get_auto_peek_info ( ).m_start_pos ) && m_type == 3 )
                {
                    auto angle = sdk::calc_ang ( g_local_player->self ( )->abs_origin ( ), g_ctx->get_auto_peek_info ( ).m_start_pos );
                    to_user_cmd.m_view_angles.y ( ) = angle.y ( );
                    to_user_cmd.m_move.x ( ) = crypt_float ( 450.f );
                    to_user_cmd.m_move.y ( ) = crypt_float ( 0.0f );
                }

                hacks::g_local_sync->handle_ctx( to_user_cmd, g_ctx->send_packet ( ) );
            }   

            valve::g_input->m_cmds [ to_user_cmd.m_number % crypt_int ( 150 ) ] = to_user_cmd;
            valve::g_input->m_vfyd_cmds [ to_user_cmd.m_number % crypt_int( 150 ) ] = { to_user_cmd, to_user_cmd.checksum ( ) };

            buffer.get ( )->write_user_cmd( &to_user_cmd, &from_user_cmd );

            auto& local_data = hacks::g_eng_pred->local_data ( ).at ( to_user_cmd.m_number % crypt_int( 150 ) );

            local_data.m_override_tick_base = true;
            local_data.m_adjusted_tick_base = first_tick_base++;

            ++shifted_cmds;

            if ( shifted_cmds >= shift_amount ) {
                if ( to_user_cmd.m_tick != std::numeric_limits < float >::max ( ) ) {
                    m_shift_cycle = false;
                    hacks::g_exploits->m_should_send = true;
                    auto& out = g_ctx->get_out_cmds( ).emplace_back( );
                    out.m_is_outgoing = true;
                    out.m_is_used = false;
                    out.m_command_nr = valve::g_client_state.get( )->m_last_cmd_out + valve::g_client_state.get( )->m_choked_cmds + crypt_int( 1 );
                    out.m_prev_command_nr = crypt_int( 0 );

                    if ( !is_zero_vec3_t( g_ctx->get_auto_peek_info( ).m_start_pos ) && m_type == 3 )
                        m_force_fake_shift = true;
                }
            }
            else {
                ++valve::g_client_state.get ( )->m_choked_cmds;
                ++valve::g_client_state.get ( )->m_net_chan->m_choked_packets;
                ++valve::g_client_state.get ( )->m_net_chan->m_out_seq;
            }

            from_user_cmd = to_user_cmd;

            ++to_user_cmd.m_number;
        } while ( shifted_cmds < shift_amount );

        m_shift_cycle = false;
    }
}
#include "../../../csgo.hpp"

namespace csgo::hacks { 
    int c_exploits::get_type( ) { 
        if( !g_local_player->self( ) )
            return 0;

        if( g_key_binds->get_keybind_state( &m_cfg->m_dt_key ) )
            return type_doubletap;

        return 0;
    }

    bool c_exploits::is_peeking( sdk::qang_t& angle, float ticks, bool auto_stop ) { 
        m_peeking_someone = false;

        if( !g_local_player->self( ) ||
            !g_local_player->self( )->weapon( ) 
            || !g_local_player->self( )->weapon( )->info( )
            || g_local_player->self( )->weapon( )->info( )->m_type == game::e_weapon_type::knife
            || g_local_player->self( )->weapon( )->item_index( ) == game::e_item_index::taser )
            return false;
            
        if( g_local_player->self( )->velocity( ).length( 2u ) < ( auto_stop ? 8.5f : 2.5f ) )
            return false;

        for( int i = 1; i <= game::g_global_vars.get( )->m_max_clients; ++i ) { 
            auto& entry = hacks::g_lag_comp->entry( i - 1 );

            if( !g_local_player->self( )
                || !g_local_player->self( )->alive( ) )
                continue;

            if( !entry.m_player || !entry.m_player->alive( )
                || entry.m_player == g_local_player->self( )
                || entry.m_player->networkable( )->dormant( )
                || entry.m_player->friendly( g_local_player->self( ) ) )
                continue;

            if( entry.m_lag_records.empty( ) )
                continue;

            aim_target_t target{ };  
            target.m_entry = &entry;
            target.m_lag_record = entry.m_lag_records.front( );

            target.m_points.clear( );

            sdk::vec3_t next_shot_pos = g_ctx->shoot_pos( ) + ( g_local_player->self( )->velocity( ) * game::g_global_vars.get( )->m_interval_per_tick ) * ticks;
            std::vector < point_t > points{ };

            lag_backup_t lag_backup{ };
            lag_backup.setup( target.m_entry->m_player );

            g_aim_bot->scan_center_points( target, target.m_lag_record.value( ), next_shot_pos, points );

            lag_backup.restore( target.m_entry->m_player );

            if( g_aim_bot->scan_points( &target, points ) ) { 
                m_peeking_someone = true;
                break;
            }
        }

        return m_peeking_someone;
    }

    void c_exploits::handle_context( game::user_cmd_t& user_cmd ) { 

        m_max_process_ticks = game::g_cvar->find_var( "sv_maxusrcmdprocessticks" )->get_int( );

        game::cs_weapon_t* weapon = g_local_player->self( )->weapon( );

        int shift_amount{ };

        if( ( m_type = get_type( ) ) ) { 
            if( weapon ) { 
                const game::e_item_index item_index = weapon->item_index( );
                if( item_index != game::e_item_index::taser
                    && item_index != game::e_item_index::c4
                    && !( item_index >= game::e_item_index::flashbang && item_index <= game::e_item_index::inc_grenade ) ) { 
                    if( m_ticks_allowed ) { 
                        if( m_type == 1 )
                            shift_amount = 8;
                        else if( m_type == 2 || m_type == 3 ) { 
                            if( hacks::g_aim_bot->can_shoot( false, 0, false ) )
                                shift_amount = m_ticks_allowed;
                        }

                        if( game::g_global_vars.get( )->m_cur_time >= g_local_player->self( )->next_attack( ) ) { 
                            m_next_shift_amount = shift_amount;
                        }

                        goto prepare_cheat;
                    }
                }
            }
        };

       m_cur_shift_amount = m_next_shift_amount = 0;

        if( !m_type && m_ticks_allowed > 0 ) { 
            m_type = type_ready;
            m_cur_shift_amount = m_next_shift_amount = m_ticks_allowed;

            m_charged = true;
        }

    prepare_cheat:
        if( weapon
            && weapon->item_index( ) == game::e_item_index::revolver ) { 
            g_eng_pred->r8_can_shoot( ) = true;

            user_cmd.m_buttons &= ~game::e_buttons::in_attack2;

            if( hacks::g_aim_bot->can_shoot( true, 0, true ) ) { 
                if( game::g_global_vars.get( )->m_cur_time < g_eng_pred->postpone_fire_ready_time( ) )
                    user_cmd.m_buttons |= game::e_buttons::in_attack;
                else if( game::g_global_vars.get( )->m_cur_time < weapon->next_secondary_attack( ) )
                    user_cmd.m_buttons |= game::e_buttons::in_attack2;
                else
                    g_eng_pred->postpone_fire_ready_time( ) = game::g_global_vars.get( )->m_cur_time + crypt_float( 0.234375f );

                g_eng_pred->r8_can_shoot( ) = game::g_global_vars.get( )->m_cur_time > g_eng_pred->postpone_fire_ready_time( );
            }
            else { 
                user_cmd.m_buttons &= ~game::e_buttons::in_attack;

                g_eng_pred->postpone_fire_ready_time( ) = game::g_global_vars.get( )->m_cur_time + crypt_float( 0.234375f );

                g_eng_pred->r8_can_shoot( ) = false;
            }
        }

        const game::weapon_info_t* wpn_data = weapon != nullptr ? weapon->info( ) : nullptr;

        if( ( m_charged )
            && ( user_cmd.m_buttons & game::e_buttons::in_attack ) 
            && wpn_data != nullptr
            && wpn_data->m_type != game::e_weapon_type::grenade ) { 
            user_cmd.m_buttons &= ~game::e_buttons::in_attack;
        }

        g_ctx->in_charge( ) = false;

        if( g_ctx->anim_data( ).m_local_data.m_shot_valid_wpn
            && g_ctx->anim_data( ).m_local_data.m_shot_cmd_number > game::g_client_state.get( )->m_last_cmd_out
            && g_ctx->anim_data( ).m_local_data.m_shot_cmd_number < ( game::g_client_state.get( )->m_last_cmd_out + crypt_int( 100 ) ) )
            g_ctx->in_charge( ) = true;

        if( m_charged ) { 
            m_allow_choke = false;
        }
        else { 
            if( m_type
                && m_ticks_allowed ) { 
                if( game::g_client_state.get( )->m_net_chan->m_choked_packets >= crypt_int( 1 ) )
                    m_allow_choke = false;
                else
                    m_allow_choke = true;
            }
            else { 
                if( game::g_client_state.get( )->m_net_chan->m_choked_packets >= crypt_int( 14 ) )
                    m_allow_choke = false;
                else
                    m_allow_choke = true;
            }
        }

        if( ( m_charged )
            && ( user_cmd.m_buttons & game::e_buttons::in_attack )
            && wpn_data->m_type != game::e_weapon_type::grenade ) { 
            user_cmd.m_buttons &= ~game::e_buttons::in_attack;
        }

        g_ctx->can_shoot( ) = g_aim_bot->can_shoot( false, m_ticks_allowed >= 14 ? 14 : 0, false );
    }

    void c_exploits::skip_lag_interpolation( bool process )
    { 
        if( !g_local_player->self( ) || !g_local_player->self( )->alive( ) )
            return;

        if( m_recharge_cmd != game::g_client_state.get( )->m_last_cmd_out )
            return;

        if( !process )
        { 
            m_prediction_tick = g_local_player->self( )->final_pred_tick( );

            g_local_player->self( )->final_pred_tick( ) = game::g_global_vars.get( )->m_tick_count + game::to_ticks( game::g_engine->net_channel_info( )->latency( game::e_net_flow::out )
                + game::g_engine->net_channel_info( )->latency( game::e_net_flow::in ) );
            return;
        }

        g_local_player->self( )->final_pred_tick( ) = m_prediction_tick;
    }
    
    bool c_exploits::try_to_recharge( bool& send_packet, game::user_cmd_t& user_cmd ) {
        if( ( game::g_global_vars.get( )->m_cur_time - g_local_player->self( )->spawn_time( ) ) < 1.f )
            return false;

        if( g_aim_bot->stop_type( )
            || g_ctx->anim_data ( ).m_local_data.m_old_shot )
            return false;

        if( m_recharge_cmd != game::g_client_state.get( )->m_last_cmd_out
            && ( game::g_client_state.get ( )->m_choked_cmds || m_ticks_allowed >= crypt_int( 14 ) ) )
            return false;

        if( !get_type ( )
            || std::abs( g_ctx->anim_data( ).m_local_data.m_last_shot_time - game::g_global_vars.get( )->m_cur_time ) < crypt_float( 0.30f ) )
            return false;

        if( m_ticks_allowed >= crypt_int( 14 ) ) {
            m_charged = true;

            if( ( m_ticks_allowed + 1 ) <= crypt_int( 16 ) ) {
                if ( m_ticks_allowed < 0 )
                    m_ticks_allowed = 0;
            }
            else
                m_ticks_allowed = 15;  

            return false;
        }

        m_recharge_cmd = game::g_client_state.get( )->m_last_cmd_out;

        if( ++m_ticks_allowed > crypt_int( 16 ) )
            m_ticks_allowed = crypt_int( 16 );

        return true;
    }

    int c_exploits::clock_correction( ) const { 

        static auto sv_clockcorrection_msecs = game::g_cvar->find_var( xor_str( "sv_clockcorrection_msecs" ) );

        return game::g_global_vars.get( )->m_max_clients <= 1
            ? -1 : game::to_ticks( std::clamp( ( sv_clockcorrection_msecs->get_float( ) / 1000.f ), 0.f, 1.f ) );
    }

    int c_exploits::adjust_tick_base( 
        const int old_new_cmds,
        const int total_new_cmds, const int delta
    ) const { 
        auto final_tick_base = -1;

        const auto correction_ticks = clock_correction( );
        if( correction_ticks != -1 ) {
            const auto& prev_local_data = g_eng_pred->local_data( ).at( game::g_client_state.get( )->m_last_cmd_out % 150 );
            if( prev_local_data.m_spawn_time == g_local_player->self( )->spawn_time( ) ) {
                final_tick_base = prev_local_data.m_tick_base + crypt_int( 1 );

                const auto tick_count = final_tick_base + old_new_cmds - m_simulation_diff;

                const auto ideal_final_tick = tick_count + correction_ticks;

                const auto too_fast_limit = ideal_final_tick + correction_ticks;
                const auto too_slow_limit = ideal_final_tick - correction_ticks;

                const auto estimated_final_tick = final_tick_base + total_new_cmds;

                if( estimated_final_tick > too_fast_limit
                    || estimated_final_tick < too_slow_limit ) {
                    final_tick_base = ideal_final_tick - total_new_cmds;
                }
            }
        }

        if( final_tick_base != -1 )
            return final_tick_base;

        const auto& local_data = g_eng_pred->local_data( ).at( ( game::g_client_state.get( )->m_last_cmd_out + 1 ) % 150 );

        return ( local_data.m_spawn_time == g_local_player->self( )->spawn_time( )
            ? local_data.m_tick_base : g_local_player->self( )->tick_base( ) ) - delta;
    }

    void c_exploits::handle_break_lc( 
        const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
        cc_def( game::bf_write_t* ) buffer, int& from, int& to, cc_def( game::move_msg_t* ) move_msg
    ) { 
        // add + 2 to max process ticks cus we wanna allow full shifting on defensive then clamp our shift to that
        int shift_amount = std::clamp( m_cur_shift_amount, 0, m_max_process_ticks );//;

        m_cur_shift_amount = 0;
        m_last_processed = game::g_global_vars.get( )->m_tick_count;

        const int actual_cmds = std::min( move_msg.get( )->m_new_cmds + m_ticks_allowed, crypt_int( 16 ) );
        int ticks_allowed { };

        const auto new_cmd = actual_cmds - move_msg.get( )->m_new_cmds;
        if( new_cmd >= 0 )
            ticks_allowed = new_cmd;

        m_ticks_allowed = ticks_allowed;

        const auto old_new_cmds = move_msg.get( )->m_new_cmds;

        move_msg.get( )->m_new_cmds = std::clamp( move_msg.get( )->m_new_cmds + shift_amount, 1, crypt_int( 62 ) );
        move_msg.get( )->m_backup_cmds = 0;

        const auto next_cmd_number = game::g_client_state.get( )->m_last_cmd_out + game::g_client_state.get( )->m_choked_cmds + crypt_int( 1 );

        for( to = next_cmd_number - old_new_cmds + 1; to <= next_cmd_number; ++to ) { 
            if( !hooks::orig_write_user_cmd_delta_to_buffer( ecx, edx, slot, buffer.get( ), from, to, true ) )
                return;
            
            from = to;
        }

       for( auto i = game::g_client_state.get( )->m_last_cmd_out + 1; i <= next_cmd_number; ++i )
            hacks::g_eng_pred->local_data( ).at ( i % 150 ).m_fake_amount = shift_amount;

        const auto user_cmd = game::g_input->user_cmd( slot, from );
        if( !user_cmd )
            return;

        auto from_user_cmd = *user_cmd, to_user_cmd = *user_cmd;

        if( shift_amount ) { 
            ++to_user_cmd.m_number;
            to_user_cmd.m_tick += 200;

            while( shift_amount ) { 
                buffer.get( )->write_user_cmd( &to_user_cmd, &from_user_cmd );

                from_user_cmd = to_user_cmd;

                ++to_user_cmd.m_number;
                ++to_user_cmd.m_tick;

                --shift_amount;
            }
        }
    }

    void c_exploits::process_real_cmds( 
        const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
        cc_def( game::bf_write_t* ) buffer, int& from, int& to, cc_def( game::move_msg_t* ) move_msg
    ) { 

        m_last_shift_tick = game::g_global_vars.get( )->m_tick_count;

        // just safety clamp incase it tries shifting more
        int shift_amount = std::clamp( m_cur_shift_amount, 0, m_max_process_ticks );

        m_cur_shift_amount = 0;

        const auto actual_cmds = std::min( move_msg.get( )->m_new_cmds + m_ticks_allowed, 16 );

        int new_ticks_allowed { };

        auto new_cmd = actual_cmds - move_msg.get( )->m_new_cmds;

        new_cmd -= shift_amount;

        if( new_cmd >= 0 )
            new_ticks_allowed = new_cmd;

        m_ticks_allowed = new_ticks_allowed;

        const auto old_new_cmds = move_msg.get( )->m_new_cmds;

        move_msg.get( )->m_new_cmds = std::clamp( move_msg.get( )->m_new_cmds + shift_amount, 1, crypt_int( 62 ) );
        move_msg.get( )->m_backup_cmds = 0;

        auto first_tick_base = adjust_tick_base( old_new_cmds, move_msg.get( )->m_new_cmds, shift_amount );

        const auto next_cmd_number = game::g_client_state.get( )->m_last_cmd_out + game::g_client_state.get( )->m_choked_cmds + crypt_int( 1 );

        for( to = next_cmd_number - old_new_cmds + 1; to <= next_cmd_number; ++to ) { 
            if( !hooks::orig_write_user_cmd_delta_to_buffer( ecx, edx, slot, buffer.get( ), from, to, true ) )
                return;

            from = to;
        }

        for( auto i = game::g_client_state.get( )->m_last_cmd_out + 1; i <= next_cmd_number; ++i ) { 
            auto& local_data = hacks::g_eng_pred->local_data( ).at( i % 150 );

            local_data.m_fake_amount = 0;
            local_data.m_override_tick_base = true;
            local_data.m_adjusted_tick_base = first_tick_base++;
        }

        const auto user_cmd = game::g_input->user_cmd( slot, from );
        if( !user_cmd )
            return;

        auto from_user_cmd = *user_cmd, to_user_cmd = *user_cmd;

        ++to_user_cmd.m_number;

        game::g_prediction->m_prev_start_frame = -1;
        game::g_prediction->m_cmds_predicted = crypt_int( 0 );

        m_shift_cycle = true;
        ++game::g_client_state.get( )->m_choked_cmds;
        ++game::g_client_state.get( )->m_net_chan->m_choked_packets;
        ++game::g_client_state.get( )->m_net_chan->m_out_seq;

        const auto& local_data = hacks::g_eng_pred->local_data( ).at( next_cmd_number % crypt_int( 150 ) );

        int shifted_cmds{ };

        do { 
            game::g_prediction->update( 
                game::g_client_state.get( )->m_delta_tick,
                game::g_client_state.get( )->m_delta_tick > 0,
                game::g_client_state.get( )->m_last_cmd_ack,
                game::g_client_state.get( )->m_last_cmd_out + game::g_client_state.get( )->m_choked_cmds
            );
            
            sdk::vec3_t shoot_pos_before_shift = g_ctx->shoot_pos( );

            // if we are mid-shifting
            if( shifted_cmds < shift_amount ) { 
                g_ctx->shoot_pos( ) = shoot_pos_before_shift;
                to_user_cmd.m_buttons &= ~( game::e_buttons::in_attack | game::e_buttons::in_attack2 ); // remove attack and scope
            }

            to_user_cmd.m_buttons &= static_cast< game::e_buttons > ( ~4290707449u );
            to_user_cmd.m_move = { };

            // we alive and this is last command we're shifting (or we are unloading dt), edit movement to teleport properly
            if( g_local_player->self( )->alive( ) ) { 

                // are we autopeeking?
                if( !g_ctx->get_auto_peek_info( ).m_start_pos.is_zero( ) && m_type == type_doubletap )
                { 
                    // get at target angle from autopeek pos
                    sdk::vec3_t angle = sdk::calc_ang( g_local_player->self( )->abs_origin( ), g_ctx->get_auto_peek_info( ).m_start_pos );

                    // if we're far enough
                    if( ( g_local_player->self( )->abs_origin( ) - g_ctx->get_auto_peek_info( ).m_start_pos ).length( 2u ) > 0.1f ) { 

                        // make our player run towards it 
                        to_user_cmd.m_view_angles.y( ) = angle.y( );
                        to_user_cmd.m_move.x( ) = crypt_float( 450.f );
                        to_user_cmd.m_move.y( ) = crypt_float( 0.0f );
                    }
                }
                else { 
                    // if we're doubletapping
                    if( m_type == type_doubletap ) { 
                        // teleport using movement before we autostopped
                        to_user_cmd.m_move.x( ) = g_ctx->m_pre_autostop_move.x( );
                        to_user_cmd.m_move.y( ) = g_ctx->m_pre_autostop_move.y( );

                        // get teleport type
                        const int tp_type = g_aim_bot->get_dt_stop_type( );

                        // if we have autostop on dt on and had a previous target
                        if( tp_type > 0 && g_exploits->m_had_target && shifted_cmds >= shift_amount - 2 ) { 

                            // force autostop
                            hacks::g_aim_bot->stop_type( ) = tp_type;
                            hacks::g_move->auto_stop( to_user_cmd, 0.f );
                        }
                    }
                    else { // else we unloaded dt, use last data
                        to_user_cmd.m_move.x( ) = local_data.m_move.x( );
                        to_user_cmd.m_move.y( ) = local_data.m_move.y( );
                    }
                }
            }

            game::g_input->m_cmds [ to_user_cmd.m_number % crypt_int( 150 ) ] = to_user_cmd;
            game::g_input->m_vfyd_cmds [ to_user_cmd.m_number % crypt_int( 150 ) ] = { to_user_cmd, to_user_cmd.checksum( ) };

            buffer.get( )->write_user_cmd( &to_user_cmd, &from_user_cmd );

            auto& local_data = hacks::g_eng_pred->local_data( ).at( to_user_cmd.m_number % crypt_int( 150 ) );

            local_data.m_override_tick_base = true;
            local_data.m_adjusted_tick_base = first_tick_base++;

            ++shifted_cmds;

            if( shifted_cmds >= shift_amount ) { 
                if( to_user_cmd.m_tick != std::numeric_limits < float >::max( ) ) { 
                    m_shift_cycle = false;
                    auto& out = g_ctx->get_out_cmds( ).emplace_back( );
                    out.m_is_outgoing = true;
                    out.m_is_used = false;
                    out.m_command_nr = game::g_client_state.get( )->m_last_cmd_out + game::g_client_state.get( )->m_choked_cmds + crypt_int( 1 );
                    out.m_prev_command_nr = crypt_int( 0 );
                }
            }
            else { 
                ++game::g_client_state.get( )->m_choked_cmds;
                ++game::g_client_state.get( )->m_net_chan->m_choked_packets;
                ++game::g_client_state.get( )->m_net_chan->m_out_seq;
            }

            from_user_cmd = to_user_cmd;

            ++to_user_cmd.m_number;
        } while( shifted_cmds < shift_amount );

        m_shift_cycle = false;
    }
}